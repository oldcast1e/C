#include <stdio.h>
#pragma warning(disable:4996)
int main()
{
   int a, i=0; // 배열 입력받기 위한 a지정
   int n1[100]; //크기 100인 배열 지정
   int n2[100]; //크기 100인 배열 지정
   int k1, k2; //입력받은 배열 크기 저장할 변수지정 

   while (1) { //무한루프
      scanf("%d", &a); //입력받기
      if (a < 0) break; //종료조건
      n1[i] = a; //배열에 넣기
      k1 = i;//개수 저장
      i++; //다음 배열 저장하기 위해 1증가
   }

   i = 0; //다음 배열 0부터 넣기 위해 초기화
   while (1) { //무한루프
      scanf("%d", &a); //입력받기
      if (a < 0) break; //종료조건
      n2[i] = a; //배열에 넣기
      k2 = i; //개수 저장
      i++; //다음 배열 저장하기 위해 1증가
   }
   int new1[100], new2[100]; //중복 제거한 n1,n2 배열저장할 새로운 변수 지정
   
   i = 0;
   for (int i = 0; i <= k1; i++) { //배열 개수 만큼 반복
      for (int j = i + 1; j <= k1; j++) { //배열 다음부터 중복있는지 판단
         if (n1[i] == -1) continue; //-1이면 패쓰
         if (n1[i] == n1[j]) { //같으면
            n1[j] = -1; //-1로 바꿔 중복 판단
         }
      }
   }
   for (int i = 0; i <= k2; i++) { //배열 개수 만큼 반복
      for (int j = i + 1; j <= k2; j++) { //배열 다음부터 중복있는지 판단
         if (n2[i] == -1) continue; //-1이면 패쓰
         if (n2[i] == n2[j]) {//같으면
            n2[j] = -1;  //-1로 바꿔 중복 판단
         }
      }
   }
   //오름차순 정리
   for (int i = 0; i <= k1; i++) { // 배열 개수 만큼 반복
      for (int j = i+1; j <= k1; j++) { //그 다음 수부터 비교하기
         if (n1[i] > n1[j]) { //앞의 수가 그다음 수보다 크면
            int tmp;// 기존 수 저장할 빈 변수
            tmp = n1[i]; //기존 수 저장
            n1[i] = n1[j];//기존 변수에 그 다음 수 저장
            n1[j] = tmp;// 그다음수에 기존 변수를 저장
         }
      }
   }

   for (int i = 0; i <= k2; i++) { // 배열 개수 만큼 반복
      for (int j = i+1; j <= k2; j++) { //그 다음 수부터 비교하기
         if (n2[i] > n2[j]) { //앞의 수가 그다음 수보다 크면
            int tmp; // 기존 수 저장할 빈 변수
            tmp = n2[i]; //기존 수 저장
            n2[i] = n2[j]; //기존 변수에 그 다음 수 저장
            n2[j] = tmp; // 그다음수에 기존 변수를 저장
         }
      }
   }
   
   int j = 0; //순서 대로 넣을 변수
   int t1, t2; //개수 저장할 변수
   for (int i = 0; i <= k1; i++) { //개수만큼 반복
      if (n1[i] == -1) continue; //-1이면 중복이므로 패쓰
      new1[j] = n1[i];//새로운 변수에 중복 제거한 변수 저장 
      //printf("new1[j]=%d\n", new1[j]); //확인 위한 출력
      j++; //저장할 다음 배열위해 1증가
      t1 = j; //개수 저장
   }

   int j1 = 0; //저장할 배열 수
   for (int i = 0; i <= k2; i++) {//개수 만큼 반복
      if (n2[i] == -1) continue; //-1이면 중복이므로 패쓰
      new2[j1] = n2[i]; //새로운 변수에 중복 제거한 변수 저장 
      //printf("new2[j]=%d\n", new2[j1]); //확인 위한 출력
      j1++;//저장할 다음 배열위해 1증가
      t2 = j1; //개수 저장
   }
   for (int i = 0; i < t2; i++) { // 두 번째 배열 개수만큼 반복
      new1[t1] = new2[i]; //배열 하나로 합치기
      //printf("new1[%d]=%d\n",t1, new1[t1]); //확인 위한 출력
      t1++;
   }

   // 중복 제거
   for (int i = 0; i <= t1+t2-1; i++) {  //두 배열 더한 개수만큼 반복
      for (int j = i + 1; j <= t1+t2-1; j++) {  //두 배열 더한 개수만큼 반복
         if (new1[i] == -1) { //-1이면 중복이므로
            continue;//패쓰
         }
         if (new1[i] == new1[j]) { //같으면
            new1[j] = -1; //-1로 중복 표시하기
         }
      }
   }

   // 오름차순 정리 
   for (int i = 0; i <= t1+t2-1; i++) { //두 배열 합친 개수만큼 반복
      for (int j = i + 1; j <= t1 + t2 - 1 ; j++) { //두 배열 합친 개수만큼 반복
         if (new1[i] > new1[j]) { //앞 순서가 더 크면
            int tmp; // 기존 수 저장할 빈 변수
            tmp = new1[i]; //앞의 수가 그다음 수보다 크면
            new1[i] = new1[j]; //바꾸기
            new1[j] = tmp; //바꾸기
         }
         //printf("new%d = %d\n", i,new1[i]);
      }
   }

   
   for (int i = 0; i <= t1 + t2 - 1; i++) { // 합친 배열 값 개수 만큼 반복
      if (new1[i] < 0) continue; //-1이면 중복이므로 패쓰
      printf(" %d", new1[i]);//출력하기
   }

      return 0;//종료
}